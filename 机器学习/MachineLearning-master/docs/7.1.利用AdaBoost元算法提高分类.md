# 第7章 利用AdaBoost元算法提高分类

![利用AdaBoost元算法提高分类](/images/7.AdaBoost/adaboost_headPage.jpg "利用AdaBoost元算法提高分类")

## 组合相似的分类器来提高分类性能

> 元算法(meta-algorithm) 或 集成方法(ensemble method)

* 概念：是对其他算法进行组合的一种形式。
* 通俗来说： 当做重要决定时，大家可能都会考虑吸取多个专家而不只是一个人的意见。
    机器学习处理问题时又何尝不是如此？ 这就是元算法(meta-algorithm)背后的思想。
* 集成方法：  1. 投票选举   2. 再学习

> bagging：基于数据随机重抽样的分类起构造方法

* 自举汇聚法(bootstrap aggregating)，也称为bagging方法，是在从原始数据集选择S次后得到S个新数据集的一种技术。
    1. 新数据集和原数据集的大小相等。
    2. 每个数据集都是通过在原始数据集中随机选择一个样本来进行替换(替换：意味着可以多次选择同一个样本，也就有重复值)而得到的。
    3. 该算法作用的数据集就会得到S个分类器，与此同时，选择分类器投票结果中最多的类别作为最后的分类结果。
    4. 例如：随机森林(random forest)
* 追美女：美女选择择偶对象的时候，会问几个闺蜜的建议，最后选择一个综合得分最高的一个作为男朋友

> boosting

* boosting是一种与bagging很类似的技术。
* 不过boosting分类的结果是基于所有分类器的加权求和结果的。不论是boosting还是bagging当中，所使用的多个分类器的类型都是一致的。
* 区别是什么？
    1. bagging：不同的分类器是通过串形训练而获得的，每个新分类器斗根据已训练出的分类器的性能来进行训练。
    2. boosting：是通过集中关注被已有分类器错分的那些数据来获得新的分类器。
    3. 由于boosting分类的结果是基于所有分类器的加权求和结果的，因此boosting与bagging不太一样。
    4. bagging中的分类器权重是相等的，而boosting中的分类器权重并不相等，每个权重代表的是其对应分类器在上一轮迭代中的成功度。
* 目前boosting方法最流行的版本是： AdaBoost。
* 追美女：第1个帅哥失败->(传授经验：姓名、家庭情况) 第2个帅哥失败->(传授经验：兴趣爱好、性格特点) 第3个帅哥成功

## 应用AdaBoost算法

> AdaBoost(adaptive boosting: 自适应boosting)

```
能否使用弱分类器和多个实例来构建一个强分类器？ 这是一个非常有趣的理论问题。

* 优点：泛化错误率低，易编码，可以应用在大部分分类器上，无参数调节。
* 缺点：对离群点敏感。
* 适用数据类型：数值型和标称型数据。
```

> AdaBoost的一般流程

```
收集数据：可以使用任意方法
准备数据：依赖于所使用的弱分类器类型，本章使用的是单层决策树，这种分类器可以处理任何数据类型。当然也可以使用任意分类器作为弱分类器，第2章到第6章中的任一分类器都可以充当弱分类器。作为弱分类器，简单分类器的效果更好。
分析数据：可以使用任意方法。
训练数据：AdaBoost的大部分时间都用在训练上，分类器将多次在同一数据集上训练弱分类器。
测试数据：计算分类的错误率。
使用算法：通SVM一样，AdaBoost预测两个类别中的一个。如果想把它应用到多个类别的场景，那么就要像多类SVM中的做法一样对AdaBoost进行修改。
```

* 训练算法： 基于错误提升分类器的性能
* 基于单层决策树构建弱分类器
    * 单层决策树(decision stump, 也称决策树桩)是一种简单的决策树。
* 过拟合(overfitting, 也称为过学习)
    * 发现测试错误率在达到一个最小值之后有开始上升，这种现象称为过拟合。
* ![过拟合](/images/7.AdaBoost/过拟合.png)

> AdaBoost的算法示意图

![AdaBoost算法示意图](/images/7.AdaBoost/adaboost_illustration.png "AdaBoost算法示意图")

> 训练算法：基于错误提升分类器的性能

```
发现：
alpha目的主要是计算每一个分类器实例的权重(组合就是分类结果)
  分类的权重值：最大的值，为alpha的加和，最小值为-最大值
D的目的是为了计算错误概率： weightedError = D.T*errArr，求最佳分类器
  特征的权重值：如果一个值误判的几率越小，那么D的特征权重越少
```

![AdaBoost算法权重计算公式](/images/7.AdaBoost/adaboost_alpha.png "AdaBoost算法权重计算公式")

## 完整AdaBoost算法的实现

整个实现的伪代码如下：

```
对每次迭代：
    利用buildStump()函数找到最佳的单层决策树
    将最佳单层决策树加入到单层决策树数组
    计算alpha
    计算新的权重向量D
    更新累计类别估计值
    如果错误率等于0.0，则退出循环
```

## 处理非均衡分类问题

> 概念

在分类器训练时，正例数目和反例数目不相等（相差很大）

> 非均衡现象：

* 判断马是否能继续生存(不可误杀)
* 过滤垃圾邮件(不可漏判)
* 不能放过传染病的人
* 不能随便认为别人犯罪

> ROC评估方法

* ROC曲线: 最佳的分类器应该尽可能地处于左上角
* ![ROC曲线](/images/7.AdaBoost/ROC曲线.png)
    * 对不同的ROC曲线进行比较的一个指标是曲线下的面积(Area Unser the Curve, AUC). 
    * AUC给出的是分类器的平均性能值，当然它并不能完全代替对整条曲线的观察。
    * 一个完美分类器的AUC为1，而随机猜测的AUC则为0.5。

> 代价函数

* 基于代价函数的分类器决策控制：`TP*(-5)+FN*1+FP*50+TN*0`
* ![代价函数](/images/7.AdaBoost/代价函数.png)

> 抽样

* 欠抽样(undersampling)或者过抽样(oversampling)
    * 欠抽样: 意味着删除样例
    * 过抽样: 意味着复制样例(重复使用)

* * *

* **作者：[片刻](http://www.apache.wiki/display/~jiangzhonglian)**
* [GitHub地址](https://github.com/apachecn/MachineLearning): <https://github.com/apachecn/MachineLearning>
* **版权声明：欢迎转载学习 => 请标注信息来源于 [ApacheCN](http://www.apache.wiki)**
